<HTML>
  <HEAD>
    <TITLE>Speed of precalculated paths vs. step-taking</TITLE>
<LINK REL=start HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=author HREF="mailto:amitp@cs.stanford.edu" /><LINK REL=prev HREF="http://theory.stanford.edu/~amitp/GameProgramming/MovingObstacles.html" />
<LINK REL=next HREF="http://theory.stanford.edu/~amitp/GameProgramming/SpaceUsage.html" />

<STYLE><!--

  BODY { background: rgb(235,235,235); color: black; margin: 0; padding: 0; }
  H1 { color: white; background-color: rgb(0,0,192);
       padding: 5pt; border: 1px solid rgb(235,235,235);
       text-align: center; font-size: 24px; font-weight: bold; 
       text-transform: capitalize; margin: none; }
  H2 { margin-left: 2em; color: rgb(0,0,255); }
  H3 { margin-left: 5em; color: rgb(0,0,192); }
  H4 { margin-left: 7em; color: rgb(0,0,128); }
  H5 { margin-left: 10em; color: rgb(0,0,64); }
  H1, H2, H3, H4, H5, P.nav { font-weight: bold;
       font-family: verdana, sans-serif; }
  TABLE.nav { margin-top: 3em; background-color: white; }
  ADDRESS { text-align: right; }
  BLOCKQUOTE { margin-left: 20%; margin-right: 20%; 
               background: rgb(192,192,192); border: none; }
  P, DIV.content { margin-left: 7em; 
              margin-right: 7em; text-align: justify; }
  OL LI { list-style-type: decimal; }
  OL OL LI { list-style-type: lower-alpha; }
  OL OL OL LI { list-style-type: lower-roman; }
  DIV.margin { width: 30%; float: right; background: white; 
               border: solid 10pt rgb(235,235,235);
               text-align: center; padding: 1ex; }
  DIV.margin HR { display: none; }
  DIV.figure { margin-left: 0em; text-align: center; }
  A:link { color: #003399; font-style: italic; }
  A:visited { color: #990066; }
  A:link:hover { color: #ffffff; background-color: #003399;
  text-decoration: none; }
  A:visited:hover { color: #ffffff; background-color: #990066;
  text-decoration: none; }
// --></STYLE>
  </HEAD>
<BODY BGCOLOR=#e8e8e8 TEXT=black LINK=blue VLINK=#600060 ALINK=red>

<h1>Speed of precalculated paths vs. step-taking</h1>

<P>The general impression of path-finding algorithms appears to be that
they are significantly slower than step-taking approaches.  Although
calculating a long path is significantly more time consuming than
taking a step, in a comparison we must instead look at a <EM>series</EM>
of steps.</P>

<h2><A NAME=S1>Predictable behavior vs. potential speed</A></h2>

<P>Step-taking usually involves a constant amount of time per step taken,
whereas path-finding involves an unknown amount of time per step
taken, because it may be difficult to predict how many map spaces are
going to be searched.  It is a good idea to try your path-finder on
some sample maps to get an idea of how much of the map is being
searched.  However, even if you tune the average case to be good
(fast), the worst case scenario in a path-finder can be worse than a
step-taker.</P>

<P>A step-taker's CPU usage is fairly easy to predict.  This can be an
advantage in many games, especially when timing is important.
Although easy to predict, the time taken may be somewhat large,
especially if sophisticated analysis is needed to determine what step
to take.  A step-taker usually recalculates information at each step:
Unless the analysis is simple, the step-taker will have to analyze the
neighboring area to determine where to move; at the next step, the
analyzed area will overlap the area analyzed previously.  A
path-finder on the other hand can perform calculations once and use
the results to analyze <EM>many</EM> steps.  If the required analysis is
complex, a path-finder may use less time overall than a step-taker.</P>

<h3><A NAME=S2>Load spikes</A></h3>

<P>One situation to take into account is in a game that allows the player
to select multiple units and select a destination for all of them.
With path-finding, there will be many paths to compute at the same
time, so you will get a <EM>load spike</EM>, a short period of very high
load (CPU usage).  Handling movement step-by-step wouldn't produce a
load spike, because the load is distributed over a long period of
time.</P>

<P>One way to avoid the load spike is to delay path-finding.  Units can
be programmed to follow either their instincts (simple movement) or
their brains (a precalculated path).  Units will follow their
instincts unless their brains tell them otherwise.  (This approach is
used in nature and also in insect-like robots at MIT labs.)  Instead
of calculating all the paths at once, limit the game to finding one
path every one, two, or three game cycles.  Then let the units start
walking according to instinct (which could simply be moving in a
straight line towards the goal), and come back later to find paths for
them.  This approach allows you to even out the cost of path-finding
so that it doesn't occur all at once.</P>

<h3><A NAME=S3>Waypoints</A></h3>

<P>Step-takers take a similar amount of time no matter how long the path
is.  Path-finders however take <EM>more</EM> than twice as much time to
find a path that is twice as long.  Remember that path-finding is
searching an <EM>area</EM>, and areas for a circle of diameter <CODE>N</CODE>
grow in proportion to <CODE>N^2</CODE>.  Also, the data structures used in
A* (such as a heap) grow at rate <CODE>N log N</CODE> rather than simply
<CODE>N</CODE>.</P>

<P>One way to reduce the growth is two split a long path into two shorter
paths.  You may ask the user to mark <EM>waypoints</EM> on the path:
instead of simply clicking on a destination, ask the user to click on
two or three points along the way to the destination.  You now have
three or four smaller paths to compute, and you save some time.  The
user also has some control over the overall path---for example, your
path-finder may have found a path to the west of some mountains, but
for safety's sake, the user wants to stay to the east of the mountains
(near friendly guard towers).</P>

<P>The main change in unit movement code will be that instead of a single
destination, you will have a list of destinations.  Find a path to the
first destination.  Once you get there, remove it from the list and
find a path to the next destination.</P>

<h2><A NAME=S4>Path recalculation</A></h2>

<P>Unfortunately, a path-finder cannot reuse the results of analysis
indefinitely.  After some time, the results may be invalidated by
updates to the map.  The step-taker can respond immediately to the
changes, but a calculated path is not going to reflect the most recent
map.  For a path-finder, the path may have to be verified or
recalculated periodically; this can be a disadvantage if paths are
long or if path updates are frequent.  For example, in a game that
allows walls and other obstacles to be blown up, a path may not be
valid for long.  Also, if the path calculation took into account enemy
positions, those would not be valid for long.  On the other hand, if
your path-finder does not take into account faraway enemy positions,
and if the obstacles on the map are fairly static, the path is likely
to be good for a longer period of time.  The more often information
used for movement changes, the more of an advantage step-taking has
over path-finding.</P>

<h3><A NAME=S5>Idle-time recalculation</A></h3>

<P>To smooth out the varying CPU load that may occur with path-finding,
the approach used to smooth out load spikes can be used with path
recalculation.  Paths can be calculated when the CPU load is low, and
recalculation can be delayed if the CPU load is high.  This puts idle
cycles to good use, and avoids slowing down the game when there's a
lot going on.</P>

<h2><A NAME=S6>Redundancy in path-finding</A></h2>

<P>Sometimes, the path found by a path-finder can be used more than once.
This reduces the cost of path-finding, since you can amortize one
search over several uses.</P>

<h3><A NAME=S7>Networked games</A></h3>

<P>Path-Finders produce a lot of information at the beginning, while
step-takers produce a small amount of information at each step.  For
networked games, the path determined by the path-finder can be
transmitted to the other machines on the network, so that the path
need be calculated only once, rather than once per machine.</P>

<h3><A NAME=S8>Multiple units</A></h3>

<DIV CLASS=margin ALIGN=center><HR><STRONG>See Also:</STRONG>
  Putting paths together is called <A HREF="MovingObstacles.html#S2">path
  splicing</A> in another section of these notes.
<HR></DIV>

<P>If many units are in or near the same location, and have the same
destination (or destinations close to each other), it is very likely
that the path found for one will be useful for other units.  One idea
is to find a path <CODE>P</CODE> from the center of the units to the center
of the destinations.  Then, use most of that path for all the units,
but replace the first 10 steps and the last 10 steps by paths that are
found for each individual unit.  Unit <EM>i</EM> will receive a path
from its starting location to <CODE>P[10]</CODE>, followed by the shared
path <CODE>P[10..len(P)-10]</CODE>, followed by a path from <CODE>P[len(P)-10]</CODE> to the destination.</P>

<P>The paths found for each unit are short (approximately 10 steps on
average), and the long path is shared.  Most of the path is found only
once and shared among all the units.  However, the user may not be
impressed if he sees all the units moving on the same path.  To
improve the appearance of the system, make the units follow slightly
different paths.  One way to do this is to alter the paths themselves,
by choosing adjacent locations.  </P>

<P>Another approach is to make the units aware of each other (perhaps by
picking a "leader" unit randomly, or by picking the one with the best
sense of what's going on), and only find a path for the leader.  Then
use a <A HREF="http://www.red.com/cwr/boids.html">flocking algorithm</A> to make
them move in a group.</P>

<h2><A NAME=S9>Summary</A></h2>

<P>Try your path-finder on sample maps to see how many spaces are
searched in relation to how many steps are taken.  Some algorithms,
such as A* using a very high heuristic, lead to a constant amount of
searching per step in common cases.  Other algorithms, such as
Dijkstra's, use a lot of searching per step.  The results will depend
on <EM>your</EM> algorithm, <EM>your</EM> heuristic, and <EM>your</EM> map
characteristics, so run some experiments.</P>

<DIV class=content><OL>
<li>If there is a lot of work that has to be done per step taken,
      a path-finder's CPU usage may be difficult to predict.  A more
      predictable, although sometimes slower, step-taker may be 
      a better choice.  If there is a small amount of work per step,
      then a path-finder's cost can be predicted, and directly compared
      to a step-taker.
<li>Also, ask yourself how often map changes will affect a path.  If
      such changes are common, path-finding will be more costly, and
      step-taking may be better.  If such changes are rare, path-finding
      may be inexpensive relative to step-taking because analysis can be
      performed once and reused for the entire path.
<li>If varying CPU load is a problem, consider load balancing by
      allowing units to continue moving with less information, until
      CPU load decreases, and a path can be found for the unit.
<li>Re-using the path found by the path-finder decreases the cost
      of path-finding, so look for ways to save and reuse the paths.
</OL>

</DIV>



<TABLE CLASS=nav WIDTH="100%" CELLPADDING=3>
<TR><TD ALIGN=LEFT WIDTH="33%">Back: <A REL=prev HREF="MovingObstacles.html">Moving Obstacles</A></TD><TD ALIGN=CENTER WIDTH="33%">Up: <A HREF=index.html>Home</A></TD><TD ALIGN=RIGHT WIDTH="33%">Next: <A REL=next HREF="SpaceUsage.html">Space</A></TD></TR>
</TABLE>


<HR><ADDRESS>
</address>
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>Last modified: Sun Nov 18 11:32:17 2001<br>From <A HREF="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game Programming Site</A></TD><TD ALIGN=RIGHT>Copyright (C) 2000, <A REL=copyright HREF="http://www-cs-students.stanford.edu/~amitp/">Amit J. Patel</A></TD></TR></TABLE>


</BODY>
</HTML>
