<HTML>
  <HEAD>
    <TITLE>Space used by precalculated paths</TITLE>
<LINK REL=start HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=author HREF="mailto:amitp@cs.stanford.edu" /><LINK REL=prev HREF="http://theory.stanford.edu/~amitp/GameProgramming/SpeedComparison.html" />
<LINK REL=next HREF="http://theory.stanford.edu/~amitp/GameProgramming/WalkingTraps.html" />

<STYLE><!--

  BODY { background: rgb(235,235,235); color: black; margin: 0; padding: 0; }
  H1 { color: white; background-color: rgb(0,0,192);
       padding: 5pt; border: 1px solid rgb(235,235,235);
       text-align: center; font-size: 24px; font-weight: bold; 
       text-transform: capitalize; margin: none; }
  H2 { margin-left: 2em; color: rgb(0,0,255); }
  H3 { margin-left: 5em; color: rgb(0,0,192); }
  H4 { margin-left: 7em; color: rgb(0,0,128); }
  H5 { margin-left: 10em; color: rgb(0,0,64); }
  H1, H2, H3, H4, H5, P.nav { font-weight: bold;
       font-family: verdana, sans-serif; }
  TABLE.nav { margin-top: 3em; background-color: white; }
  ADDRESS { text-align: right; }
  BLOCKQUOTE { margin-left: 20%; margin-right: 20%; 
               background: rgb(192,192,192); border: none; }
  P, DIV.content { margin-left: 7em; 
              margin-right: 7em; text-align: justify; }
  OL LI { list-style-type: decimal; }
  OL OL LI { list-style-type: lower-alpha; }
  OL OL OL LI { list-style-type: lower-roman; }
  DIV.margin { width: 30%; float: right; background: white; 
               border: solid 10pt rgb(235,235,235);
               text-align: center; padding: 1ex; }
  DIV.margin HR { display: none; }
  DIV.figure { margin-left: 0em; text-align: center; }
  A:link { color: #003399; font-style: italic; }
  A:visited { color: #990066; }
  A:link:hover { color: #ffffff; background-color: #003399;
  text-decoration: none; }
  A:visited:hover { color: #ffffff; background-color: #990066;
  text-decoration: none; }
// --></STYLE>
  </HEAD>
<BODY BGCOLOR=#e8e8e8 TEXT=black LINK=blue VLINK=#600060 ALINK=red>

<h1>Space used by precalculated paths</h1>

<P>Sometimes, it's not the time needed to calculate a path, but the space
used by paths for hundreds of units that is the limiting factor.
Step-takers typically use very little space, while path-finders
require space for the algorithm to run, plus space to store a path.</P>

<h2><A NAME=S1>Locations vs. directions</A></h2>

<P>A path can be either locations or directions.  Locations take more
space, but have the advantage that it is easy to determine an
arbitrary location or direction in the path without traversing the
path.  When storing directions, only the direction can be determined
easily; the location can only be determined by going through the
entire path, following the directions.  In a typical grid map,
locations may be stored with two 16-bit integers, making each step
take 32 bits.  There are far fewer directions, however, so they can
take less space.  If the unit can move in only four directions, each
step takes only 2 bits; if the unit can move in six or eight
directions, each step takes 3 bits.  Either of these is a significant
savings over storing locations in the path.  Hannu Kankaanpaa suggests
that you can further reduce the space requirement by storing the <EM>relative</EM> direction ("turn right 60 degrees") instead of the absolute
direction ("go north").  Some relative directions may not make sense
for some types of units.  For example, if your unit is moving north,
it's unlikely that the next step is to go south.  In a six directional
game, you have only five meaningful directions.  On some maps, perhaps
only three of those directions (straight, left 60 degrees, right 60
degrees) make sense, but on other maps, turning right 120 degrees may
be a valid move (for example, when going up a steep mountain path with
switchbacks).</P>

<h2><A NAME=S2>Path compression</A></h2>

<P>Once a path can be found, it can be compressed in some way.  A general
purpose compression algorithm could be used, but will not be discussed
here.  A compression algorithm specific to paths could be used to
shorten either location-based paths or direction-based paths.  Before
deciding, look at typical paths in your game to decide which kind of
compression will work best.  In addition, consider ease of
implementation (and debugging), the size of the code, and whether it
really matters.  If you have a limit of 300 units and only 50 are
walking at any one time, and paths are short (100 steps), the total
memory requirement might only be &lt;50k anyway, and not worth worrying
about compression.</P>

<h3><A NAME=S3>Location storage</A></h3>

<P>In maps where obstacles rather than terrain are the main influence in
determining paths, there may be many straight-line segments in the
path.  If this is the case, then a path need contain only the
endpoints (sometimes called <EM>waypoints</EM>) of those line segments.
Movement consists of examining the next point on the path and moving
in a straight line towards it.</P>

<h3><A NAME=S4>Direction storage</A></h3>

<P>When directions are stored, it may be the case that a particular
direction is followed many times in a row.  You can take advantage of
that common pattern to store the path in less space.</P>

<P>One way to store the path is to store both a direction and a number
which indicates how many times the unit should move in that direction.
Unlike the optimization for location storage, this optimization can
make things worse if a direction is not taken many times in a row.
Also, for many straight lines where location compression is useful,
direction compression is not, since the line may not be aligned with
one of the walking directions.  With relative directions, you can
eliminate "keep going forward" as a possible direction.  Hannu points
out that with an eight direction map, you can eliminate forwards,
backwards, and the 135 degree left and right turns (assuming your map
allows it), and you can then store each direction with only two bits.</P>

<P>Another way to store the path is to use variable length encoding.
The idea is to use a single bit (0) for the most
common step: go straight.  Use a 1 to mark a turn, and follow the 1 by
some number of bits to represent the turn.  In a four directional map,
you can turn only left or right, so you might use 10 for left and 11
for right.  </P>

<P>Variable length encoding is more general and may compress better than
run length encoding for mixed paths, but not as well for long straight
paths.  The sequence (north, straight six steps, turn left, straight
three steps, turn right, straight five steps, turn left, straight two
steps) is represented as [(NORTH, 6), (WEST, 3), (NORTH, 5), (WEST,
2)] with run length encoding.  If each direction is two bits and each
distance is eight bits, this path requires 40 bits to store.  With
variable length encoding, you use one bit for each step and two bits
for each turn -- [NORTH 0 0 0 0 0 0 10 0 0 0 11 0 0 0 0 0 10 0 0] -- a
total of 24 bits.  If the initial direction and each turn imply one
step, you can save one bit per turn, resulting in 20 bits to store the
path.  However, longer paths can take more space with variable length
encoding.  The sequence (north, straight two hundred steps) is
[(NORTH, 200)] with run length encoding, a total of 10 bits.  The same
sequence with variable length encoding is [NORTH 0 0 ...], a total of
202 bits.  </P>

<h2><A NAME=S5>Beacons</A></h2>

<P>A <EM>beacon</EM> is a spot marked as good for paths.  For example,
ancient trade routes often would pass particular points, which often
became trading towns.  Given knowledge of those beacons, a path-finder
can use known paths between beacons and only calculate a path to the
first beacon on the journey and from the last beacon on the journey.
This approach is commonly used by people travelling: a person
determines the path from the starting point to a train station or
airport, and then takes a predetermined path to another train station
or airport, then finally determines a path to the destination.  The
path-finder searches a path from beacon to beacon, rather than one
step at a time.  These large-step paths involve a large number of
steps but a small amount of storage, since only the location of the
next beacon is stored in the path.  Beacons work well on hand drawn
maps but may be difficult to determine on computer generated maps.</P>

<h2><A NAME=S6>Limited path length</A></h2>

<P>Given that map conditions or orders may change, it may not make sense
to store a long path, since at some point the remainder of the path
may not be of any use.  Each unit can store a fixed number of steps at
the beginning of the path, and then use path recalculation when the
path has almost been traversed.  This approach allows for control of
the amount of data used per unit.</P>

<h2><A NAME=S7>Summary</A></h2>

<P>Paths can potentially take up a lot of space in a game, especially
when the paths are long and there are many units present.  Path
compression, waypoints, and beacons reduce the space requirements by
storing many steps in a small amount of data.  Waypoints rely on
straight-line segments being common so that we have to store only the
endpoints, while beacons rely on there being well-known paths
calculated beforehand between specially marked places on the map.  If
paths still take up too much space, the path length can be limited,
resulting in the classic time-space tradeoff: to save space,
information can be forgotten and recalculated later.</P>



<TABLE CLASS=nav WIDTH="100%" CELLPADDING=3>
<TR><TD ALIGN=LEFT WIDTH="33%">Back: <A REL=prev HREF="SpeedComparison.html">Speed</A></TD><TD ALIGN=CENTER WIDTH="33%">Up: <A HREF=index.html>Home</A></TD><TD ALIGN=RIGHT WIDTH="33%">Next: <A REL=next HREF="WalkingTraps.html">Walking Traps</A></TD></TR>
</TABLE>


<HR><ADDRESS>
</address>
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>Last modified: Sun Nov 18 11:32:17 2001<br>From <A HREF="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game Programming Site</A></TD><TD ALIGN=RIGHT>Copyright (C) 2000, <A REL=copyright HREF="http://www-cs-students.stanford.edu/~amitp/">Amit J. Patel</A></TD></TR></TABLE>


</BODY>
</HTML>
