<HTML>
  <HEAD>
    <TITLE>Heuristics</TITLE>
<LINK REL=start HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=author HREF="mailto:amitp@cs.stanford.edu" /><LINK REL=prev HREF="http://theory.stanford.edu/~amitp/GameProgramming/Goals.html" />
<LINK REL=next HREF="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html" />

<STYLE><!--

  BODY { background: rgb(235,235,235); color: black; margin: 0; padding: 0; }
  H1 { color: white; background-color: rgb(0,0,192);
       padding: 5pt; border: 1px solid rgb(235,235,235);
       text-align: center; font-size: 24px; font-weight: bold; 
       text-transform: capitalize; margin: none; }
  H2 { margin-left: 2em; color: rgb(0,0,255); }
  H3 { margin-left: 5em; color: rgb(0,0,192); }
  H4 { margin-left: 7em; color: rgb(0,0,128); }
  H5 { margin-left: 10em; color: rgb(0,0,64); }
  H1, H2, H3, H4, H5, P.nav { font-weight: bold;
       font-family: verdana, sans-serif; }
  TABLE.nav { margin-top: 3em; background-color: white; }
  ADDRESS { text-align: right; }
  BLOCKQUOTE { margin-left: 20%; margin-right: 20%; 
               background: rgb(192,192,192); border: none; }
  P, DIV.content { margin-left: 7em; 
              margin-right: 7em; text-align: justify; }
  OL LI { list-style-type: decimal; }
  OL OL LI { list-style-type: lower-alpha; }
  OL OL OL LI { list-style-type: lower-roman; }
  DIV.margin { width: 30%; float: right; background: white; 
               border: solid 10pt rgb(235,235,235);
               text-align: center; padding: 1ex; }
  DIV.margin HR { display: none; }
  DIV.figure { margin-left: 0em; text-align: center; }
  A:link { color: #003399; font-style: italic; }
  A:visited { color: #990066; }
  A:link:hover { color: #ffffff; background-color: #003399;
  text-decoration: none; }
  A:visited:hover { color: #ffffff; background-color: #990066;
  text-decoration: none; }
// --></STYLE>
  </HEAD>
<BODY BGCOLOR=#e8e8e8 TEXT=black LINK=blue VLINK=#600060 ALINK=red>

<h1>Heuristics</h1>

<P>When using a heuristic-based algorithm like A*, you may wonder what
kind of heuristic you should use.  In this section I will cover mostly
ideas for <EM>grid maps</EM>.  If you use A* on a polygonal map, you may
want different heuristics.  The heuristic should be a <EM>continuous</EM> function; jumps in the heuristic from one map space to its
neighbor may cause A* to behave strangely.</P>

<P>A* does best (<EM>i.e.,</EM> finds an optimal path in the least time)
when the distance is close to the minimal path cost from the current
node to the goal.  However, we may want some modifications to the
heuristic to give us better behavior, depending on what we really
need.  For example, we may not need the <EM>optimal</EM> path, or
perhaps we want different characteristics for the beginning of the
path and the end of the path.</P>

<h2><A NAME=S1>Manhattan distance</A></h2>

<P>The standard heuristic is the Manhattan distance.  Look at your cost
function and see what the least cost is for moving from one space to
another.  In my game, it is 10.  Therefore, the heuristic in my game
should be 10 times the Manhattan distance:</P>

<BLOCKQUOTE>
<CODE>h(A) = 10 * (abs(A.x-goal.x) + abs(A.y-goal.y))</CODE>

</BLOCKQUOTE>

<P>You should use the scale that matches your cost function.</P>

<h2><A NAME=S2>Diagonal distance</A></h2>

<P>If on your map you allow diagonal movement, then you need a different
heuristic.  The Manhattan distance for (4 east, 4 north) will be 8.
However, you could simply move (4 northeast) instead, so the heuristic
should be 4.  This function handles diagonals:</P>

<BLOCKQUOTE>
<CODE>h(A) = max(abs(A.x-goal.x), abs(A.y-goal.y))</CODE>

</BLOCKQUOTE>

<h2><A NAME=S3>Straight line distance</A></h2>

<P>If your units can move at any angle (instead of grid directions), then
you should probably use a straight line distance:</P>

<BLOCKQUOTE>
<CODE>h(A) = sqrt((A.x-goal.x)^2 + (A.y-goal.y)^2)</CODE>

</BLOCKQUOTE>

<h2><A NAME=S4>Guessing path quality</A></h2>

<P>Instead of assuming the path is the best possible, you could check for
obvious obstacles, and increase your path cost if you find some.  To
do this, construct a polygonal estimate of the map (make polygons for
impassable areas, but ignore passable terrain, no matter how difficult
it is to traverse).  Then when you are looking at the distance from
the current position to the goal, you can scan for simple obstacles
and draw a line around them.  The length of that line can be your
heuristic.</P>

<h2><A NAME=S5>Breaking ties</A></h2>

<P>One thing that can lead to poor performance is ties in the heuristic.
When several paths have the same <CODE>f</CODE> value, they are all
explored, even though we only need to explore one of them.  To solve
this problem, we can add a small tie-breaker to the heuristic.  This
tie breaker also can give us nicer looking paths:</P>

<BLOCKQUOTE>
<CODE>double dx1 = currentX - goalX;</CODE><br>
<CODE>double dy1 = currentY - goalY;</CODE><br>
<CODE>double dx2 = startX - goalX;</CODE><br>
<CODE>double dy2 = startY - goalY;</CODE><br>
<CODE>cross = dx1*dy2 - dx2*dy1;</CODE><br>
<CODE>if( cross&lt;0 ) cross = -cross;</CODE><br>
<CODE>... add cross*0.001 to the heuristic ...</CODE><br>


</BLOCKQUOTE>

<P>This code computes the vector cross-product between the start to goal
vector and the current point to goal vector.  When these vectors don't
line up, the cross product will be larger.  The result is that this
code will give some slight preference to a path that lies along the
straight line path from the start to the goal.  <EM>It can
significantly improve the speed of path-finding when there are few
obstacles around.</EM></P>

<P>To see a demonstration of the improvement from this fudge factor, see
<A HREF="http://www.ccg.leeds.ac.uk/james/aStar/">James Macgill's A*
applet</A>.  Use "Clear" to clear the map, and choose two points on
opposite corners of the map.  When you use the "Classic A*" method,
you will see the effect of ties.  When you use the "Fudge" method, you
will see the effect of the above cross product added to the heuristic.</P>

<h2><A NAME=S6>Searching for an area</A></h2>

<P>If you want to search for any spot near some goal, instead of one
particular space, you could construct a heuristic <CODE>h'(x)</CODE> that is
the minimum of <CODE>h1(x), h2(x), h3(x), ...</CODE> where <CODE>h1, h2, h3</CODE>
are heuristics to each of the nearby spots.  However, a faster way is
to just let A* search for the center of the goal area.  Once you pull
<EM>any</EM> nearby space from the OPEN set, you can stop and construct
a path.</P>



<TABLE CLASS=nav WIDTH="100%" CELLPADDING=3>
<TR><TD ALIGN=LEFT WIDTH="33%">Back: <A REL=prev HREF="Goals.html">Goals</A></TD><TD ALIGN=CENTER WIDTH="33%">Up: <A HREF=index.html>Home</A></TD><TD ALIGN=RIGHT WIDTH="33%">Next: <A REL=next HREF="MovementCosts.html">Movement Costs</A></TD></TR>
</TABLE>


<HR><ADDRESS>
</address>
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>Last modified: Sun Nov 18 11:32:17 2001<br>From <A HREF="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game Programming Site</A></TD><TD ALIGN=RIGHT>Copyright (C) 2000, <A REL=copyright HREF="http://www-cs-students.stanford.edu/~amitp/">Amit J. Patel</A></TD></TR></TABLE>


</BODY>
</HTML>
