<HTML>
  <HEAD>
    <TITLE>Movement costs for path-finders</TITLE>
<LINK REL=start HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=author HREF="mailto:amitp@cs.stanford.edu" /><LINK REL=prev HREF="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" />
<LINK REL=next HREF="http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html" />

<STYLE><!--

  BODY { background: rgb(235,235,235); color: black; margin: 0; padding: 0; }
  H1 { color: white; background-color: rgb(0,0,192);
       padding: 5pt; border: 1px solid rgb(235,235,235);
       text-align: center; font-size: 24px; font-weight: bold; 
       text-transform: capitalize; margin: none; }
  H2 { margin-left: 2em; color: rgb(0,0,255); }
  H3 { margin-left: 5em; color: rgb(0,0,192); }
  H4 { margin-left: 7em; color: rgb(0,0,128); }
  H5 { margin-left: 10em; color: rgb(0,0,64); }
  H1, H2, H3, H4, H5, P.nav { font-weight: bold;
       font-family: verdana, sans-serif; }
  TABLE.nav { margin-top: 3em; background-color: white; }
  ADDRESS { text-align: right; }
  BLOCKQUOTE { margin-left: 20%; margin-right: 20%; 
               background: rgb(192,192,192); border: none; }
  P, DIV.content { margin-left: 7em; 
              margin-right: 7em; text-align: justify; }
  OL LI { list-style-type: decimal; }
  OL OL LI { list-style-type: lower-alpha; }
  OL OL OL LI { list-style-type: lower-roman; }
  DIV.margin { width: 30%; float: right; background: white; 
               border: solid 10pt rgb(235,235,235);
               text-align: center; padding: 1ex; }
  DIV.margin HR { display: none; }
  DIV.figure { margin-left: 0em; text-align: center; }
  A:link { color: #003399; font-style: italic; }
  A:visited { color: #990066; }
  A:link:hover { color: #ffffff; background-color: #003399;
  text-decoration: none; }
  A:visited:hover { color: #ffffff; background-color: #990066;
  text-decoration: none; }
// --></STYLE>
  </HEAD>
<BODY BGCOLOR=#e8e8e8 TEXT=black LINK=blue VLINK=#600060 ALINK=red>

<h1>Movement costs for path-finders</h1>

<P>When using a path-finding algorithm, you may want to treat map spaces
as something other than <EM>clear</EM> and <EM>blocked</EM>.  Often
there is more information available, such as the difficulty of moving
through that area.  For example, swamps and mountains may be more
difficult to pass than grasslands and desert.  With some algorithms,
like A*, you can put this encode this information into the cost
function.  Listed below are some ideas for movement costs that might
be useful.</P>

<h2><A NAME=S1>Altitude</A></h2>

<P>High altitudes (such as mountains) can have a higher movement cost
than low altitudes.  With this cost function, your units will try to
stay in the lowlands whenever possible.  For example, if the source
and destination are both at high altitudes, the unit might move
downhill, travel for a while, and then move back uphill.</P>

<h3><A NAME=S2>Moving uphill</A></h3>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
You can find an example of using hills in the
              movement cost in my A* code, in the <CODE>UnitMovement</CODE>
              class.<br>

<HR></DIV>

<P>Instead of high altitudes having a high cost, <EM>moving</EM> uphill
can have a high cost.  This avoids the odd situation described above.
With this cost function, units try to avoid moving uphill.  Faced with
the same situation, the unit will try to avoid moving back uphill at
the end; it can do this by staying at a high altitude throughout its
travels.  A cost function such as this one may be good for units such
as soldiers, which can move downhill easily but have a hard time going
uphill.</P>

<h3><A NAME=S3>Moving up- or downhill</A></h3>

<P>Some units, such as tanks, have a hard time moving uphill <EM>or</EM>
downhill.  You can assign a high cost to moving downhill, and an even
higher cost to moving uphill.  The units will try to avoid changing
altitudes.</P>

<h2><A NAME=S4>Terrain</A></h2>

<P>You may want different types of terrain to have different movement costs.</P>

<h3><A NAME=S5>Forests, mountains, and hills</A></h3>

<P>Instead of relying on altitude, you may want to use terrain types.
(For example, Civilization does this.)  Each terrain type can have a
movement cost associated with it.  This movement table might apply to
all units, or different movement tables could be associated with each
unit type.  For example, soldiers might have no trouble moving through
forests, but tanks might have a very hard time.  A fancier method is
to assign movement costs to <EM>changing</EM> terrain.  Going from
grassland into mountains could be more expensive than going from hills
to mountains, which could be more expensive than going from mountains
to mountains.</P>

<h3><A NAME=S6>Roads</A></h3>

<P>In many games, the primary purpose of roads is to make movement
possible or easier.  After choosing a movement cost function, you can
add a road modifier to it.  One possibility is to divide the cost by
some constant (such as two); another is to assign a fixed cost to
movement along a road.</P>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
You can find an example of using roads in the
              movement cost in my A* code, in the <CODE>UnitMovement</CODE>
              class.<br>

<HR></DIV>

<P>I strongly advise that you do <EM>not</EM> make road movement free
(zero-cost).  This confuses path-finding algorithms such as A*,
because it introduces the possibility that the shortest path from one
point to another is along a winding road that seems to lead nowhere.
The algorithm has to search a very wide area to make sure that no such
roads exist.  Note that in the game Civilization, railroads had
zero-cost movement, but when using the "Auto Goto" function, railroads
had a non-zero cost.  This is evidence that a path-finding algorithm
was being used.</P>

<h3><A NAME=S7>Walls or other barriers</A></h3>

<P>Instead of checking both movement costs and for obstacles in your
path-finding algorithm, you can just use movement costs.  Just assign
a very high movement cost to any obstacle.  When expanding nodes (in
the A* algorithm), check if the cost is too high; if it is, then throw
the node out.</P>

<h3><A NAME=S8>Sloped Land</A></h3>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
You can find an example of using land slopes in the
              movement cost in my A* code, in the <CODE>FlatCanalPath</CODE>
              class.<br>

<HR></DIV>

<P>Instead of using <EM>movement</EM> up and down hills, you might want to
make movement on any hill expensive.  To do this, compute the overall
slope of the terrain (by looking at the maximum difference between the
current tail and its neighbors), and use that as part of the movement
cost.  Land that is very steep will have a high cost and land that is
shallow will have a low cost.  This approach differs from the movement
uphill/downhill cost in that it looks for <EM>land</EM> that is steep,
while the previous approach looked for units that <EM>move</EM> in a
steep direction.  In particular, if you're on a hill and can move left
or right without going up or down, the uphill/downhill approach will
consider it a low cost, while this approach will consider it a high
cost (because the land is steep even if you aren't going up or down).</P>

<P>Sloped land costs may not make sense for unit movement, but you can
use path-finding for more than finding paths for units.  I use it for
finding paths for roads, canals, bridges, and so on.  If you want to
build these items on flat land, you can take land slope into account
when finding a path for a road or canal.  See <A HREF="Applications.html">the section on applications</A> for more ideas.</P>

<h2><A NAME=S9>Enemies and friendly units</A></h2>

<P>Another modifier can help you avoid enemy units.  Using 
<A HREF="http://www.gameai.com/influ.thread.html">influence
maps</A>, you can keep track of areas that are near enemy or
friendly units.  The influence map has a positive value for friendly
units and a negative value for enemy units.  By increasing the
movement cost whenever you are in negative territory, you can
influence your units to stay away from the enemy.</P>

<P>Even more complicated (and perhaps not possible with influence maps)
is to look at <EM>visibility</EM>: is your unit visible by an enemy
unit?  Is your unit detectable in some other way?  Is it possible for
that enemy unit to fire on you?</P>

<h2><A NAME=S10>Marked beacons</A></h2>

<P>If your map is designed and not automatically generated, you can add
extra information to it.  For example, you can mark certain positions
as <STRONG>beacons</STRONG>, and pre-calculate good paths between beacons.
The paths between beacons can have a lower movement cost than other
paths; that way, the path finding algorithm could gravitate towards
one of these predetermined paths.  You can imagine a plateau (normal
movement costs) with a canyon (paths between beacons); if the
path-finding algorithm falls into the canyon, it's likely to stay in
there.  This could cut the time it takes to find a path (but find less
optimal paths); however, I have not tried this technique so I am not
sure it works.</P>

<P>Another way to think about this technique is that you need to make
<EM>decisions</EM> about where to move next.  With beacons, you do not
need to make very many decisions---you simply decide which beacon to
visit next, instead of where to turn at each step.</P>

<P>Good choices for beacons include lighthouses, cities, mountain
passes, and bridges.</P>

<h2><A NAME=S11>Fuel Consumption</A></h2>

<P>In addition to looking at the <EM>time</EM> it takes to go somewhere,
you may want to consider the <EM>fuel</EM> it takes.  The fuel
consumption may be given more weight when the unit's fuel level is
lower.</P>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
To keep the state space small, you need to round off
              the fuel value to a coarse measurement unit.  
              Unfortunately, this makes the search less effective.<br>

<HR></DIV>

<P>To track the fuel usage through the map, you need to use state space,
as described in <A HREF="MapRepresentations.html#S8"></A>.  The state would be the pair
&lt;location, fuel&gt;.  However, state space can become very large, so it
may be worth looking at alternatives to using ordinary A*.</P>

<P>One alternative is <A HREF="ftp://ftp.cs.bham.ac.uk/pub/authors/B.S.Logan/aaai-98.ps.gz">A* with
Bounded Costs</A> (ABC).  With ABC, you can assign a bound ("20 gallons")
to a cost ("fuel").</P>



<TABLE CLASS=nav WIDTH="100%" CELLPADDING=3>
<TR><TD ALIGN=LEFT WIDTH="33%">Back: <A REL=prev HREF="Heuristics.html">Heuristics</A></TD><TD ALIGN=CENTER WIDTH="33%">Up: <A HREF=index.html>Home</A></TD><TD ALIGN=RIGHT WIDTH="33%">Next: <A REL=next HREF="UserExperience.html">User experience with shortest paths</A></TD></TR>
</TABLE>


<HR><ADDRESS>
</address>
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>Last modified: Sun Nov 18 11:32:17 2001<br>From <A HREF="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game Programming Site</A></TD><TD ALIGN=RIGHT>Copyright (C) 2000, <A REL=copyright HREF="http://www-cs-students.stanford.edu/~amitp/">Amit J. Patel</A></TD></TR></TABLE>


</BODY>
</HTML>
