<HTML>
  <HEAD>
    <TITLE>Introduction</TITLE>
<LINK REL=start HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=author HREF="mailto:amitp@cs.stanford.edu" /><LINK REL=prev HREF="http://theory.stanford.edu/~amitp/GameProgramming/index.html" />
<LINK REL=next HREF="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html" />

<STYLE><!--

  BODY { background: rgb(235,235,235); color: black; margin: 0; padding: 0; }
  H1 { color: white; background-color: rgb(0,0,192);
       padding: 5pt; border: 1px solid rgb(235,235,235);
       text-align: center; font-size: 24px; font-weight: bold; 
       text-transform: capitalize; margin: none; }
  H2 { margin-left: 2em; color: rgb(0,0,255); }
  H3 { margin-left: 5em; color: rgb(0,0,192); }
  H4 { margin-left: 7em; color: rgb(0,0,128); }
  H5 { margin-left: 10em; color: rgb(0,0,64); }
  H1, H2, H3, H4, H5, P.nav { font-weight: bold;
       font-family: verdana, sans-serif; }
  TABLE.nav { margin-top: 3em; background-color: white; }
  ADDRESS { text-align: right; }
  BLOCKQUOTE { margin-left: 20%; margin-right: 20%; 
               background: rgb(192,192,192); border: none; }
  P, DIV.content { margin-left: 7em; 
              margin-right: 7em; text-align: justify; }
  OL LI { list-style-type: decimal; }
  OL OL LI { list-style-type: lower-alpha; }
  OL OL OL LI { list-style-type: lower-roman; }
  DIV.margin { width: 30%; float: right; background: white; 
               border: solid 10pt rgb(235,235,235);
               text-align: center; padding: 1ex; }
  DIV.margin HR { display: none; }
  DIV.figure { margin-left: 0em; text-align: center; }
  A:link { color: #003399; font-style: italic; }
  A:visited { color: #990066; }
  A:link:hover { color: #ffffff; background-color: #003399;
  text-decoration: none; }
  A:visited:hover { color: #ffffff; background-color: #990066;
  text-decoration: none; }
// --></STYLE>
  </HEAD>
<BODY BGCOLOR=#e8e8e8 TEXT=black LINK=blue VLINK=#600060 ALINK=red>

<h1>Introduction</h1>

<P>I will be focusing on the <STRONG>A* Algorithm</STRONG>.  A* is probably your
best choice for path-finding, since it can be significantly faster
than Dijkstra's algorithm or Best-First Search (BFS).  It was
developed in 1968 to combine heuristic methods (which use information
about the problem to be solved to make decisions) and formal methods
(which don't use problem-specific information, but can be formally
analyzed).  The overall structure is a graph searching algorithm.
Unlike most graph searching algorithms, A* utilizes a heuristic
function that estimates how close any spot on the map is to the goal.
By using the heuristic, it can guide its search to look in the best
direction first.  If that fails, it can look at other paths.  I won't
go into the details of the algorithm; instead I'll first describe the
behavior of A*, then concentrate on my analysis of using this
algorithm for games.  I recommend looking up A* in an AI textbook to
learn how the algorithm works in detail.</P>

<h2><A NAME=S1>The A* Algorithm</A></h2>

<P>Most path-finding algorithms are written for arbitrary graphs rather
than grid-based games.  We'd like to find something that can take
advantage of the grid nature of the map.  There are some things we
consider common sense, but that algorithms don't understand.  For
example, we know something about directions: we know that in general,
as two things get farther apart, it will take a longer to move from
one to the other; and we know that there aren't any secret wormholes
that let you teleport from one spot on the map to another.  (Well, I
assume there aren't any; if there are, it becomes very hard to find a
good path because you don't know where to look first.)</P>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
For most of this document, we will assume that A* is being
              used on a grid in a tile-based game.  However, A* was 
              designed for use with graphs, and it can be used in 
              different ways in games -- see <A HREF="index.html">the section on polygonal obstacles</A> for an example.<br>

<HR></DIV>

<P>A* is like other graph-searching algorithms in that it can potentially
search a huge area of the map.  It is also like step-taking algorithms
in that it starts out going straight for the goal.  (This is the
primary difference between A* and Dijkstra: A* has a heuristic
function to guide its search towards the goal; Dijkstra has no such
information, and searches in all directions.)  Unlike the step-takers,
however, A* can "backtrack" if going straight for the goal doesn't
take you there.  It does this as it's going by keeping track of
possible grid spots that might lead to a good path.  For example, if
you were heading towards a town and came to a fork in the road, and
decided to go left instead of right, you'd probably remember that if
you didn't find the town, you could come back and try the other path.
A* does the same thing.</P>

<P>So far, this sounds very much like Best-First Search.  The main
difference is that BFS will keep looking down one path as long as it
thinks it's getting closer to the goal, until it gets to a dead-end.
A* will go down several paths at once if they all look like they're
getting closer to the goal.  A* looks at the path that has the lowest
"cost" from beginning to end, whereas BFS looks at the path that has
the lowest cost from the current point to the end.  BFS ignores the
cost of the path taken so far, so it is possible for it to go off on a
wild goose chase on some long expensive path that <EM>seems</EM> to be
good.  A* would look at other paths as soon as that path got
expensive.  In the next section we will look at the heuristic
function, which is a guess of the cost from the current point to the
end.</P>

<P>If you find the goal by going straight, then you don't really need to
search the things in the backtrack list.  That's why A* is pretty fast
most of the time.  It puts things on the list but it can throw them
away if it finds the goal.</P>

<h2><A NAME=S2>The Heuristic</A></h2>

<P>The heuristic function <CODE>h(p)</CODE> tells A* an <EM>estimate</EM> of
the cost from the current position <CODE>p</CODE> to the goal.  To find the
best path, A* uses both the heuristic and <CODE>g(p)</CODE>, the cost of
the best path from the start to <CODE>p</CODE>.  The sum of these two values
is called the estimated cost, <CODE>f(p)</CODE>.</P>

<P>It's important to choose a good heuristic function.  A bad heuristic
can really slow down A* or make it produce bad paths.  If you want A*
to give you "perfect" paths, the heuristic function should be an
<EM>underestimate</EM> of the actual cost of getting from one spot to
the goal.  Be careful that you don't underestimate <EM>too much</EM>
however.  A low heuristic won't give A* much information, and it'll
keep telling A* that there are better paths available, so it will take
longer to give you a path.</P>

<P>An interesting note: If your heuristic is <EM>exact</EM>, then A* will
<EM>never</EM> stray from the best path.  Of course, it's hard to get an
exact heuristic, but it's nice to know that A* will act perfectly when
you give it perfect information.  (Also note that in the sometimes
common case where you have no obstacles, the heuristic <EM>can</EM> be
perfect.)  Another thing that may be interesting is that as your
heuristic gets closer to being perfect, A* has to search less and
less.  This gives me confidence that it's using the heuristic well --
if it wasn't, then a perfect heuristic probably would lead to an
inefficient search.  If there aren't any obstacles or nasty terrain
squares in the way, then the heuristic (which is usually the number of
steps to the goal) <EM>is</EM> perfect, and A* will head straight
towards the goal and not look anywhere else on the map.  The way to
think about this is that the increase in the <CODE>f</CODE> value is related
to how much is searched.  When the heuristic is perfect, <CODE>f</CODE> never
changes.  When the heuristic underestimates too much, <CODE>f</CODE> increases
quickly.  The better the heuristic, the less <CODE>f</CODE> increases, and the
less of the map is searched.</P>

<DIV CLASS=margin ALIGN=center><HR><STRONG>Note:</STRONG><br>
Technically, the <STRONG>A*</STRONG> algorithm should be called simply 
              <STRONG>A</STRONG> if the heuristic is an underestimate.  However, I
              will continue to call it <STRONG>A*</STRONG> because the implementation
              is the same.<br>

<HR></DIV>

<P>You may not want "perfect" paths.  You might want to get "reasonable"
paths quickly instead of perfect paths take some time to find,
especially if you are writing a real-time game.  For this, there are
several things you can do to speed up A*.  First, you don't have to
have an underestimating heuristic.  If your heuristic function <A HREF="http://www-cs-students.stanford.edu/~amitp/Articles/AStar1.html">overestimates some of the time</A>, it can find the goal quicker.
Alternatively, you can adjust your "cost" function to more closely
match your heuristic.</P>

<P>For example, if your game has two types of terrain, Flat and Mountain,
and the movement costs are 1 for flat land and 3 for mountains, A* is
going to search three times as far along flat land as it does along
mountainous land.  This is because it's <EM>possible</EM> that there is
a path along flat terrain that goes around the mountains.  You can
speed up A*'s search by using 1.5 as the heuristic distance between
two map spaces.  A* will then compare 3 to 1.5, and it won't look as
bad as comparing 3 to 1.  It is not as dissatisfied with mountainous
terrain, so it won't spend as much time trying to find a way around
it.  You can also speed up A*'s search by decreasing the amount it
searches for paths around mountains: just tell A* that the movement
cost on mountains is 2 instead of 3.  Now it will search only twice as
far along the flat terrain as along mountainous terrain.</P>

<P>A*'s ability to vary its behavior based on the heuristic and cost
functions can be very useful in a game.  The tradeoff between speed
and accuracy can be exploited to make your game faster.</P>

<h2><A NAME=S3>Speed or Accuracy?</A></h2>

<P>For most games, you don't <EM>really</EM> need the <STRONG>best</STRONG> path
between two points.  You just need something that's close.  What you
need may depend on what's going on in the game, or how fast the
computer is.</P>

<h3><A NAME=S4>Computer speed</A></h3>

<P>If your game is running on a slow computer, you can adjust your A*
heuristic to approximate more.  This will speed up A*, so your game
won't slow to a crawl on those older computers.  Conversely, if it is
running on a fast computer, you can adjust the heuristic to give
better paths.  You have more CPU time, so why not use it to make the
game run better?  This seems to be a good situation -- players who have
powerful computers can get more out of the game; yet you don't leave
everyone else with an unplayable game.</P>

<h3><A NAME=S5>Number of units</A></h3>

<P>As the number of military units on the map increases, it's going to
use up more CPU time.  You can just adjust the heuristics to give more
approximate paths as the unit count goes up.  This will keep your game
from slowing down too much.  Also, it's realistic.  A general with a
large army doesn't have as much time to spend planning each unit's
movement as a general with a small army.  The result?  The large
army's general thinks less per unit -- the equivalent of A* searching
less of the map.  Human players aren't going to be able to think as
well when controlling a large force, so a computer that thinks less
per unit might be a more realistic opponent.</P>

<h3><A NAME=S6>Implementation ideas</A></h3>

<P>As the game is running, you can keep track of how much time is being
spent on A* searches.  If the time exceeds some threshold, you can
adjust the heuristic function towards speed and away from accuracy.
If it's lower than some threshold, you can make the heuristic more
accurate.  A self-adjusting heuristic takes care of both computer
speed and number of units, and you don't have to spend time "tuning"
it yourself.</P>



<TABLE CLASS=nav WIDTH="100%" CELLPADDING=3>
<TR><TD ALIGN=LEFT WIDTH="33%">Back: <A REL=prev HREF="index.html">Home</A></TD><TD ALIGN=CENTER WIDTH="33%">Up: <A HREF=index.html>Home</A></TD><TD ALIGN=RIGHT WIDTH="33%">Next: <A REL=next HREF="ImplementationNotes.html">Implementation</A></TD></TR>
</TABLE>


<HR><ADDRESS>
</address>
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>Last modified: Sun Nov 18 11:32:17 2001<br>From <A HREF="http://www-cs-students.stanford.edu/~amitp/gameprog.html">Amit's Game Programming Site</A></TD><TD ALIGN=RIGHT>Copyright (C) 2000, <A REL=copyright HREF="http://www-cs-students.stanford.edu/~amitp/">Amit J. Patel</A></TD></TR></TABLE>


</BODY>
</HTML>
